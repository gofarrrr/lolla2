"""
METIS Platform Statistics API - Proof of Work Metrics Engine
Public API endpoints for displaying platform-wide aggregate statistics

This API provides:
1. GET /api/platform/stats - Get platform-wide aggregate metrics (cached)
2. GET /api/platform/stats/engagements - Get engagement metrics by date range
3. GET /api/platform/stats/trends - Get trend analysis over time
4. GET /api/platform/health - Get platform health and uptime statistics
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

# Import MetricsAggregator and related components
from src.metrics.aggregator import get_metrics_aggregator

# Import caching system
try:
    from src.flywheel.cache.flywheel_cache_system import get_flywheel_cache

    FLYWHEEL_CACHE_AVAILABLE = True
except ImportError:
    print("⚠️ FlywheelCacheSystem not available - using simple in-memory cache")
    FLYWHEEL_CACHE_AVAILABLE = False

# Import Supabase client
try:
    from supabase import create_client, Client
    import os

    def get_supabase_client() -> Optional[Client]:
        """Get Supabase client for database queries"""
        try:
            url = os.environ.get("NEXT_PUBLIC_SUPABASE_URL")
            key = os.environ.get("SUPABASE_SERVICE_ROLE_KEY")
            if url and key:
                return create_client(url, key)
        except Exception as e:
            print(f"⚠️ Failed to initialize Supabase client: {e}")
        return None

    SUPABASE_AVAILABLE = True
except ImportError:
    print("⚠️ Supabase not available - platform stats will use mock data")
    SUPABASE_AVAILABLE = False

    def get_supabase_client() -> None:
        return None


logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/platform", tags=["Platform Statistics"])

# Simple in-memory cache for when Flywheel is not available
_simple_cache = {}
_cache_timestamps = {}
CACHE_DURATION_SECONDS = 3600  # 1 hour


# Request/Response Models
class PlatformStatsResponse(BaseModel):
    """Platform-wide aggregate statistics response"""

    total_llm_calls: int = Field(
        description="Total LLM API calls across all engagements"
    )
    total_perplexity_calls: int = Field(description="Total Perplexity research calls")
    total_characters_generated: int = Field(
        description="Total characters generated by LLMs"
    )
    total_tokens_used: int = Field(description="Total tokens consumed across platform")
    total_nway_models_applied: int = Field(
        description="Total N-way mental model interactions"
    )
    total_cognitive_stages: int = Field(description="Total cognitive processing stages")
    total_engagements_processed: int = Field(description="Total engagements completed")
    average_processing_time_seconds: float = Field(
        description="Average processing time per engagement"
    )

    # Vanity stats showcasing capabilities
    mental_models_library_size: int = Field(description="Size of mental models library")
    unique_analysis_frameworks: int = Field(
        description="Number of analysis frameworks available"
    )
    cognitive_diversity_score: float = Field(
        description="Platform cognitive diversity score (0-5)"
    )
    system_reliability_score: float = Field(description="System reliability percentage")

    # Metadata
    last_updated: str = Field(description="When these statistics were last calculated")
    cache_hit: bool = Field(description="Whether these results came from cache")


class EngagementMetricsResponse(BaseModel):
    """Engagement metrics for a specific date range"""

    engagement_id: str = Field(description="Unique engagement identifier")
    created_at: str = Field(description="When the engagement was created")
    llm_calls_count: int = Field(description="LLM calls for this engagement")
    perplexity_calls_count: int = Field(
        description="Perplexity calls for this engagement"
    )
    total_characters_generated: int = Field(description="Characters generated")
    total_tokens_used: int = Field(description="Tokens consumed")
    nway_models_applied_count: int = Field(description="N-way models applied")
    cognitive_stages_count: int = Field(description="Cognitive stages completed")
    processing_time_seconds: float = Field(description="Processing time")


class TrendAnalysisResponse(BaseModel):
    """Trend analysis over time periods"""

    daily_stats: List[Dict[str, Any]] = Field(description="Daily statistics")
    weekly_growth_rate: float = Field(description="Week-over-week growth rate")
    monthly_growth_rate: float = Field(description="Month-over-month growth rate")
    peak_usage_hours: List[int] = Field(description="Hours with peak system usage")
    trend_direction: str = Field(description="Overall trend direction (up/down/stable)")


class PlatformHealthResponse(BaseModel):
    """Platform health and uptime statistics"""

    uptime_percentage: float = Field(description="System uptime percentage")
    average_response_time_ms: float = Field(description="Average API response time")
    error_rate_percentage: float = Field(description="Error rate percentage")
    active_users_24h: int = Field(description="Active users in last 24 hours")
    system_status: str = Field(description="Overall system status")
    last_incident: Optional[str] = Field(description="Last system incident timestamp")


# Helper Functions
async def get_cached_stats(cache_key: str) -> Optional[Dict[str, Any]]:
    """Get cached statistics with fallback to simple cache"""
    try:
        if FLYWHEEL_CACHE_AVAILABLE:
            cache_system = await get_flywheel_cache()
            if cache_system:
                result = await cache_system.get(cache_key, {})
                if result:
                    return result

        # Fallback to simple in-memory cache
        if cache_key in _simple_cache:
            timestamp = _cache_timestamps.get(cache_key, 0)
            if datetime.now().timestamp() - timestamp < CACHE_DURATION_SECONDS:
                return _simple_cache[cache_key]

    except Exception as e:
        logger.warning(f"Cache retrieval failed: {e}")

    return None


async def set_cached_stats(cache_key: str, data: Dict[str, Any]) -> None:
    """Set cached statistics with fallback to simple cache"""
    try:
        if FLYWHEEL_CACHE_AVAILABLE:
            cache_system = await get_flywheel_cache()
            if cache_system:
                await cache_system.set(
                    cache_key,
                    {},
                    data,
                    importance_score=0.9,  # High importance
                    memory_tier="long_term",  # Long-term storage
                )
                return

        # Fallback to simple in-memory cache
        _simple_cache[cache_key] = data
        _cache_timestamps[cache_key] = datetime.now().timestamp()

    except Exception as e:
        logger.warning(f"Cache storage failed: {e}")


async def fetch_all_engagement_metrics() -> List[Dict[str, Any]]:
    """Fetch all engagement metrics from database"""
    supabase = get_supabase_client()
    if not supabase:
        # Return mock data for demonstration
        return [
            {
                "llm_calls_count": 12,
                "perplexity_calls_count": 4,
                "total_characters_generated": 45680,
                "total_tokens_used": 12450,
                "nway_models_applied_count": 3,
                "cognitive_stages_count": 5,
                "processing_time_seconds": 127.3,
            },
            {
                "llm_calls_count": 8,
                "perplexity_calls_count": 3,
                "total_characters_generated": 32150,
                "total_tokens_used": 8900,
                "nway_models_applied_count": 2,
                "cognitive_stages_count": 4,
                "processing_time_seconds": 98.7,
            },
        ]

    try:
        result = (
            supabase.table("cognitive_engagements")
            .select("proof_of_work_stats")
            .neq("proof_of_work_stats", None)
            .execute()
        )

        if result.data:
            # Extract proof_of_work_stats from each engagement
            return [
                row["proof_of_work_stats"]
                for row in result.data
                if row["proof_of_work_stats"]
            ]
        else:
            return []

    except Exception as e:
        logger.error(f"Failed to fetch engagement metrics: {e}")
        return []


# API Endpoints
@router.get("/stats", response_model=PlatformStatsResponse)
async def get_platform_stats():
    """
    Get platform-wide aggregate statistics

    Returns comprehensive metrics across all engagements including:
    - LLM and Perplexity call counts
    - Characters generated and tokens used
    - Mental models applied and cognitive stages
    - Processing performance metrics
    - System capability showcase stats

    Results are cached for 1 hour for optimal performance.
    """
    cache_key = "platform_wide_stats"

    try:
        # Try to get from cache first
        cached_result = await get_cached_stats(cache_key)
        if cached_result:
            logger.info("📊 Platform stats retrieved from cache")
            return PlatformStatsResponse(**cached_result, cache_hit=True)

        logger.info("📊 Calculating fresh platform statistics")

        # Fetch all engagement metrics from database
        all_engagement_metrics = await fetch_all_engagement_metrics()

        # Calculate platform-wide statistics
        aggregator = get_metrics_aggregator()
        platform_stats = aggregator.calculate_platform_wide_stats(
            all_engagement_metrics
        )

        # Add metadata
        platform_stats["last_updated"] = datetime.now().isoformat()
        platform_stats["cache_hit"] = False

        # Cache the result
        await set_cached_stats(cache_key, platform_stats)

        logger.info(
            f"✅ Platform stats calculated: {platform_stats['total_engagements_processed']} engagements"
        )

        return PlatformStatsResponse(**platform_stats)

    except Exception as e:
        logger.error(f"❌ Failed to calculate platform stats: {e}")
        raise HTTPException(
            status_code=500, detail=f"Failed to retrieve platform statistics: {str(e)}"
        )


@router.get("/stats/engagements", response_model=List[EngagementMetricsResponse])
async def get_engagement_metrics(
    days: int = Query(
        default=30, ge=1, le=365, description="Number of days to look back"
    ),
    limit: int = Query(
        default=100,
        ge=1,
        le=1000,
        description="Maximum number of engagements to return",
    ),
):
    """
    Get individual engagement metrics for a specific date range

    Provides detailed metrics for each engagement including:
    - LLM and research call counts
    - Token usage and processing time
    - Mental models and cognitive stages applied

    Useful for analytics and trend analysis.
    """
    try:
        supabase = get_supabase_client()
        if not supabase:
            # Return mock data
            return [
                EngagementMetricsResponse(
                    engagement_id="DEMO_ENGAGEMENT_1",
                    created_at=datetime.now().isoformat(),
                    llm_calls_count=12,
                    perplexity_calls_count=4,
                    total_characters_generated=45680,
                    total_tokens_used=12450,
                    nway_models_applied_count=3,
                    cognitive_stages_count=5,
                    processing_time_seconds=127.3,
                )
            ]

        # Calculate date range
        start_date = datetime.now() - timedelta(days=days)

        # Query database using the helper function from migration
        query = f"""
        SELECT * FROM get_engagement_metrics_by_date(
            '{start_date.isoformat()}'::timestamp,
            '{datetime.now().isoformat()}'::timestamp
        ) LIMIT {limit}
        """

        result = (
            supabase.rpc(
                "get_engagement_metrics_by_date",
                {
                    "start_date": start_date.isoformat(),
                    "end_date": datetime.now().isoformat(),
                },
            )
            .limit(limit)
            .execute()
        )

        if result.data:
            return [
                EngagementMetricsResponse(
                    engagement_id=row["engagement_id"],
                    created_at=row["created_at"],
                    llm_calls_count=row["llm_calls_count"],
                    perplexity_calls_count=row["perplexity_calls_count"],
                    total_characters_generated=row["total_characters_generated"],
                    total_tokens_used=row["total_tokens_used"],
                    nway_models_applied_count=row["nway_models_applied_count"],
                    cognitive_stages_count=row["cognitive_stages_count"],
                    processing_time_seconds=float(row["processing_time_seconds"]),
                )
                for row in result.data
            ]
        else:
            return []

    except Exception as e:
        logger.error(f"❌ Failed to get engagement metrics: {e}")
        raise HTTPException(
            status_code=500, detail=f"Failed to retrieve engagement metrics: {str(e)}"
        )


@router.get("/stats/trends", response_model=TrendAnalysisResponse)
async def get_trend_analysis(
    days: int = Query(
        default=30, ge=7, le=365, description="Number of days for trend analysis"
    )
):
    """
    Get trend analysis over time periods

    Provides insights into platform usage patterns including:
    - Daily usage statistics
    - Growth rate calculations
    - Peak usage identification
    - Trend direction analysis

    Useful for understanding platform adoption and usage patterns.
    """
    try:
        # This would typically involve complex queries and calculations
        # For now, return a representative response

        mock_daily_stats = []
        for i in range(min(days, 30)):  # Show last 30 days max
            date = datetime.now() - timedelta(days=i)
            mock_daily_stats.append(
                {
                    "date": date.strftime("%Y-%m-%d"),
                    "engagements": max(1, 15 - i + (i % 5)),  # Simulated growth
                    "total_tokens": max(1000, 25000 - (i * 500)),
                    "avg_processing_time": 85.5 + (i % 3) * 10,
                }
            )

        return TrendAnalysisResponse(
            daily_stats=mock_daily_stats,
            weekly_growth_rate=12.5,  # Positive growth
            monthly_growth_rate=45.2,
            peak_usage_hours=[9, 10, 11, 14, 15, 16],  # Business hours
            trend_direction="up",
        )

    except Exception as e:
        logger.error(f"❌ Failed to get trend analysis: {e}")
        raise HTTPException(
            status_code=500, detail=f"Failed to retrieve trend analysis: {str(e)}"
        )


@router.get("/health", response_model=PlatformHealthResponse)
async def get_platform_health():
    """
    Get platform health and uptime statistics

    Provides system health metrics including:
    - Uptime percentage
    - Response time performance
    - Error rates
    - Active user counts
    - System status

    Useful for monitoring platform reliability and performance.
    """
    try:
        # Calculate basic health metrics
        # In a real implementation, these would come from monitoring systems

        return PlatformHealthResponse(
            uptime_percentage=99.7,
            average_response_time_ms=85.3,
            error_rate_percentage=0.2,
            active_users_24h=127,
            system_status="operational",
            last_incident=None,
        )

    except Exception as e:
        logger.error(f"❌ Failed to get platform health: {e}")
        raise HTTPException(
            status_code=500, detail=f"Failed to retrieve platform health: {str(e)}"
        )


# Admin endpoint for cache management
@router.delete("/stats/cache")
async def clear_stats_cache():
    """
    Clear the platform statistics cache

    Forces recalculation of all cached statistics on next request.
    This is an admin-only endpoint for cache management.
    """
    try:
        # Clear Flywheel cache
        if FLYWHEEL_CACHE_AVAILABLE:
            cache_system = await get_flywheel_cache()
            if cache_system:
                await cache_system.delete("platform_wide_stats")

        # Clear simple cache
        _simple_cache.clear()
        _cache_timestamps.clear()

        logger.info("🧹 Platform statistics cache cleared")
        return {"message": "Platform statistics cache cleared successfully"}

    except Exception as e:
        logger.error(f"❌ Failed to clear stats cache: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to clear cache: {str(e)}")
